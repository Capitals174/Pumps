class Capacitor:
    def __init__(self, g_steam, p_steam, p_n, p_k, t_h, p_sk,
              tp=540, t_air=20, pr_air=0.703, v_air=15.06 * 10 ** (-6),
              e_d=0.9, kpd_t=0.95, lambd_d=50, d1=0.024, d2=0.026,
              lz=7.5, d=3, ny=75.86, nx=75.86, nsum =5754,
              lamb_air=0.0259):
        self.g_steam = g_steam
        self.p_steam = p_steam
        self.p_n = p_n
        self.p_k = p_k
        self.t_h = t_h
        self.p_sk = p_sk
        self.tp = tp
        self.t_air = t_air
        self.pr_air = pr_air
        self.v_air = v_air
        self.kpd_t = kpd_t
        self.lambd_d = lambd_d
        self.d1 = d1
        self.d2= d2
        self.lz = lz
        self.d = d
        self.ny = ny
        self.d1 = d1
        self.d2= d2
        self.lz = lz
        self.d = d
        self.nsum = nsum
        self.nx = nx
        self.lamb_air = lamb_air
        self.e_d = e_d

    # Приложение В IV Определение температуры насыщения по давлению насыщения
    def satu_temp_by_satur_pressure(self):
        beta = self.p_sk / 10 ** 0.25
        e = beta ** 2 - 17.073846940092 * beta + 14.91510861353
        f = 1167.0521452767 * beta ** 2 + 12020.82470247 * beta - 4823.2657361591
        g = -724213.16703206 * beta ** 2 - 3232555.0322333 * beta + 405113.40542057
        d = 2 * g / (-f - (f ** 2 - 4 * e * g) ** 0.5)
        t4_p = (650.17534844798 + d - (
                    (650.17534844798 + d) ** 2 - 4 * (-0.23855557567849 + 650.17534844798 * d)) ** 0.5) / 2
        return t4_p

    # Приложение В I Определение удельной энтальпии недогретой воды по значениям абсолютных давления и температуры
    def spec_enthalpy_of_subcooled_water(self):
        i1 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 8, 8, 21, 23, 29, 30, 31,
              32]
        j1 = [-2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17, -4, 0, 6, -5, -2, 10, -8, -11, -6, -29,
              -31,
              -38, -39, -40, -41]
        n1 = [0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872,
              0.15772038513228,
              -0.016616417199501, 8.1214629983568E-04, 2.8319080123804E-04, -6.0706301565874E-04, -0.018990068218419,
              -0.032529748770505, -0.021841717175414, -5.283835796993E-05, -4.7184321073267E-04, -3.0001780793026E-04,
              4.7661393906987E-05, -4.4141845330846E-06, -7.2694996297594E-16, -3.1679644845054E-05,
              -2.8270797985312E-06,
              -8.5205128120103E-10, -2.2425281908E-06, -6.5171222895601E-07, -1.4341729937924E-13, -4.0516996860117E-07,
              -1.2734301741641E-09, -1.7424871230634E-10, -6.8762131295531E-19, 1.4478307828521E-20,
              2.6335781662795E-23,
              -1.1947622640071E-23, 1.8228094581404E-24, -9.3537087292458E-26]
        r = 0.461526
        pi = (self.p_sk / 10) / 16.53
        tau = 1386 / (self.t_s + 273)
        gamma_der_tau = 0
        for elem in range(len(i1)):
            gamma_der_tau += (n1[elem] * (7.1 - pi) ** i1[elem] * j1[elem] * (tau - 1.222) ** (j1[elem] - 1))
        h1 = r * (self.t_s + 273) * tau * gamma_der_tau
        return h1

    # Приложение В II Определение удельной энтропии недогретой воды по значениям абсолютных давления и температуры
    def spec_entropy_of_subcooled_water(self):
        i1 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 8, 8, 21, 23, 29, 30, 31,
              32]
        j1 = [-2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17, -4, 0, 6, -5, -2, 10, -8, -11, -6, -29,
              -31,
              -38, -39, -40, -41]
        n1 = [0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872,
              0.15772038513228,
              -0.016616417199501, 8.1214629983568E-04, 2.8319080123804E-04, -6.0706301565874E-04, -0.018990068218419,
              -0.032529748770505, -0.021841717175414, -5.283835796993E-05, -4.7184321073267E-04, -3.0001780793026E-04,
              4.7661393906987E-05, -4.4141845330846E-06, -7.2694996297594E-16, -3.1679644845054E-05,
              -2.8270797985312E-06,
              -8.5205128120103E-10, -2.2425281908E-06, -6.5171222895601E-07, -1.4341729937924E-13, -4.0516996860117E-07,
              -1.2734301741641E-09, -1.7424871230634E-10, -6.8762131295531E-19, 1.4478307828521E-20,
              2.6335781662795E-23,
              -1.1947622640071E-23, 1.8228094581404E-24, -9.3537087292458E-26]
        r = 0.461526
        pi = self.p_sk / 16.53
        tau = 1386 / (self.t_s + 273)
        gamma = 0
        gamma_der_tau = 0
        for i in range(34):
            gamma_der_tau += (n1[i] * (7.1 - pi) ** i1[i] * j1[i] * (tau - 1.222) ** (j1[i] - 1))
            gamma += n1[i] * (7.1 - pi) ** i1[i] * (tau - 1.222) ** j1[i]

        s = r * tau * gamma_der_tau - r * gamma
        return s

    # Приложение В III. Определение удельного объема недогретой жидкости:
    def volume_of_subcooled_liquid(self):
        i1 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 8, 8, 21, 23, 29, 30, 31,
              32]
        j1 = [-2, -1, 0, 1, 2, 3, 4, 5, -9, -7, -1, 0, 1, 3, -3, 0, 1, 3, 17, -4, 0, 6, -5, -2, 10, -8, -11, -6, -29,
              -31,
              -38, -39, -40, -41]
        n1 = [0.14632971213167, -0.84548187169114, -3.756360367204, 3.3855169168385, -0.95791963387872,
              0.15772038513228,
              -0.016616417199501, 8.1214629983568E-04, 2.8319080123804E-04, -6.0706301565874E-04, -0.018990068218419,
              -0.032529748770505, -0.021841717175414, -5.283835796993E-05, -4.7184321073267E-04, -3.0001780793026E-04,
              4.7661393906987E-05, -4.4141845330846E-06, -7.2694996297594E-16, -3.1679644845054E-05,
              -2.8270797985312E-06,
              -8.5205128120103E-10, -2.2425281908E-06, -6.5171222895601E-07, -1.4341729937924E-13, -4.0516996860117E-07,
              -1.2734301741641E-09, -1.7424871230634E-10, -6.8762131295531E-19, 1.4478307828521E-20,
              2.6335781662795E-23,
              -1.1947622640071E-23, 1.8228094581404E-24, -9.3537087292458E-26]
        r = 0.461526
        pi = self.p_sk / 16.53
        tau = 1386 / (self.t_s + 273)
        gamma_der_pi = 0
        for i in range(34):
            gamma_der_pi += -1 * n1[i] * i1[i] * (7.1 - pi) ** (i1[i] - 1) * (tau - 1.222) ** j1[i]

        v1 = r * (self.t_s + 273) / self.p_sk * pi * gamma_der_pi / 1000
        return v1

    # Приложение В VI Определение удельной энтальпии перегретого пара
    def superheated_steam_enthalpy(self):
        j0 = [0, 1, -5, -4, -3, -2, -1, 2, 3]
        n0 = [-9.6927686500217, 10.086655968018, -0.005608791128302, 0.071452738081455, -0.40710498223928,
              1.4240819171444,
              -4.383951131945, -0.28408632460772, 0.021268463753307]
        ir = [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5, 6, 6, 6, 7, 7, 7, 8, 8, 9, 10, 10, 10, 16, 16,
              18,
              20, 20, 20, 21, 22, 23, 24, 24, 24]
        jr = [0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35, 1, 2, 3, 7, 3, 16, 35, 0, 11, 25, 8, 36, 13, 4, 10, 14, 29,
              50,
              57, 20, 35, 48, 21, 53, 39, 26, 40, 58]
        nr = [-1.7731742473213E-03, -0.017834862292358, -0.045996013696365, -0.057581259083432, -0.05032527872793,
              -3.3032641670203E-05, -1.8948987516315E-04, -3.9392777243355E-03, -0.043797295650573,
              -2.6674547914087E-05,
              2.0481737692309E-08, 4.3870667284435E-07, -3.227767723857E-05, -1.5033924542148E-03, -0.040668253562649,
              -7.8847309559367E-10, 1.2790717852285E-08, 4.8225372718507E-07, 2.2922076337661E-06, -1.6714766451061E-11,
              -2.1171472321355E-03, -23.895741934104, -5.905956432427E-18, -1.2621808899101E-06, -0.038946842435739,
              1.1256211360459E-11, -8.2311340897998, 1.9809712802088E-08, 1.0406965210174E-19, -1.0234747095929E-13,
              -1.0018179379511E-09, -8.0882908646985E-11, 0.10693031879409, -0.33662250574171, 8.9185845355421E-25,
              3.0629316876232E-13, -4.2002467698208E-06, -5.9056029685639E-26, 3.7826947613457E-06,
              -1.2768608934681E-15,
              7.3087610595061E-29, 5.5414715350778E-17, -9.436970724121E-07]
        r = 0.461526
        pi = self.p_steam / 10
        tau = 540 / (self.tp + 273)
        g0_tau = 0
        for k in range(len(j0)):
            g0_tau += n0[k] * j0[k] * tau ** (j0[k] - 1)

        gr_tau = 0
        for numb in range(43):
            gr_tau += nr[numb] * pi ** ir[numb] * ir[numb] * (tau - 0.5) ** (jr[numb] - 1)

        h2 = r * (self.tp + 273) * tau * (g0_tau + gr_tau)
        return h2

    # Приложение В VII Определение удельной энтропии перегретого пара
    def superheated_steam_entropy(self):
        from math import log
        j0 = [0, 1, -5, -4, -3, -2, -1, 2, 3]
        n0 = [-9.6927686500217, 10.086655968018, -0.005608791128302, 0.071452738081455, -0.40710498223928,
              1.4240819171444,
              -4.383951131945, -0.28408632460772, 0.021268463753307]
        ir = [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5, 6, 6, 6, 7, 7, 7, 8, 8, 9, 10, 10, 10, 16, 16,
              18,
              20, 20, 20, 21, 22, 23, 24, 24, 24]
        jr = [0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35, 1, 2, 3, 7, 3, 16, 35, 0, 11, 25, 8, 36, 13, 4, 10, 14, 29,
              50,
              57, 20, 35, 48, 21, 53, 39, 26, 40, 58]
        nr = [-1.7731742473213E-03, -0.017834862292358, -0.045996013696365, -0.057581259083432, -0.05032527872793,
              -3.3032641670203E-05, -1.8948987516315E-04, -3.9392777243355E-03, -0.043797295650573,
              -2.6674547914087E-05,
              2.0481737692309E-08, 4.3870667284435E-07, -3.227767723857E-05, -1.5033924542148E-03, -0.040668253562649,
              -7.8847309559367E-10, 1.2790717852285E-08, 4.8225372718507E-07, 2.2922076337661E-06, -1.6714766451061E-11,
              -2.1171472321355E-03, -23.895741934104, -5.905956432427E-18, -1.2621808899101E-06, -0.038946842435739,
              1.1256211360459E-11, -8.2311340897998, 1.9809712802088E-08, 1.0406965210174E-19, -1.0234747095929E-13,
              -1.0018179379511E-09, -8.0882908646985E-11, 0.10693031879409, -0.33662250574171, 8.9185845355421E-25,
              3.0629316876232E-13, -4.2002467698208E-06, -5.9056029685639E-26, 3.7826947613457E-06,
              -1.2768608934681E-15,
              7.3087610595061E-29, 5.5414715350778E-17, -9.436970724121E-07]
        r = 0.461526
        pi = self.p_steam / 10
        tau = 540 / (self.tp + 273)
        g0 = log(pi)
        g0_tau = 0
        for i in range(len(j0)):
            g0 += n0[i] * tau ** j0[i]
            g0_tau += n0[i] * j0[i] * tau ** (j0[i] - 1)

        gr = 0
        gr_tau = 0
        for i in range(43):
            gr += nr[i] * pi ** ir[i] * (tau - 0.5) ** jr[i]
            gr_tau += nr[i] * pi ** ir[i] * jr[i] * (tau - 0.5) ** (jr[i] - 1)

        s = r * (tau * (g0_tau + gr_tau) - (g0 + gr))
        return s

    # Приложение В VIII Определение удельного объема перегретого пара
    def superheated_steam_volume(self):
        j0 = [0, 1, -5, -4, -3, -2, -1, 2, 3]
        n0 = [-9.6927686500217, 10.086655968018, -0.005608791128302, 0.071452738081455, -0.40710498223928,
              1.4240819171444,
              -4.383951131945, -0.28408632460772, 0.021268463753307]
        ir = [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 5, 6, 6, 6, 7, 7, 7, 8, 8, 9, 10, 10, 10, 16, 16,
              18,
              20, 20, 20, 21, 22, 23, 24, 24, 24]
        jr = [0, 1, 2, 3, 6, 1, 2, 4, 7, 36, 0, 1, 3, 6, 35, 1, 2, 3, 7, 3, 16, 35, 0, 11, 25, 8, 36, 13, 4, 10, 14, 29,
              50,
              57, 20, 35, 48, 21, 53, 39, 26, 40, 58]
        nr = [-1.7731742473213E-03, -0.017834862292358, -0.045996013696365, -0.057581259083432, -0.05032527872793,
              -3.3032641670203E-05, -1.8948987516315E-04, -3.9392777243355E-03, -0.043797295650573,
              -2.6674547914087E-05,
              2.0481737692309E-08, 4.3870667284435E-07, -3.227767723857E-05, -1.5033924542148E-03, -0.040668253562649,
              -7.8847309559367E-10, 1.2790717852285E-08, 4.8225372718507E-07, 2.2922076337661E-06, -1.6714766451061E-11,
              -2.1171472321355E-03, -23.895741934104, -5.905956432427E-18, -1.2621808899101E-06, -0.038946842435739,
              1.1256211360459E-11, -8.2311340897998, 1.9809712802088E-08, 1.0406965210174E-19, -1.0234747095929E-13,
              -1.0018179379511E-09, -8.0882908646985E-11, 0.10693031879409, -0.33662250574171, 8.9185845355421E-25,
              3.0629316876232E-13, -4.2002467698208E-06, -5.9056029685639E-26, 3.7826947613457E-06,
              -1.2768608934681E-15,
              7.3087610595061E-29, 5.5414715350778E-17, -9.436970724121E-07]
        r = 0.461526
        pi = self.p_sk / 10
        tau = 540 / (self.tp + 273)
        g0_pi = 1 / pi
        gr_pi = 0
        for i in range(43):
            gr_pi += nr[i] * ir[i] * pi ** (ir[i] - 1) * (tau - 0.5) ** jr[i]

        v2 = r * (self.tp + 273) / (self.p_sk / 10) * pi * (g0_pi + gr_pi) / 1000
        return v2

    def water_first(self, t):
        dp = self.p_n - self.p_k
        beta3 = 7 * 10 ** (-5) * t ** 2 - 0.0107 * t + 1.2209
        v_cv = -6.2532 * dp ** 2 + 11.014 * dp + 0.9291
        ro_hv = -0.0028 * t ** 2 - 0.1521 * t + 1002.3
        g_vod = ro_hv * beta3 * v_cv
        return g_vod

    def calculation(self):
        f_d = 3.14 * (self.d + 2 * ((self.d2 - self.d1) / 2)) * self.lz
        s_cw = 3.14 * self.d1 ** 2 * self.nsum / 4
        S_pipe = (self.d - self.d2 * self.nx) * self.lz
        h_tur = self.superheated_steam_enthalpy() * 1000  # удельная энтальпия
        s_tur = self.superheated_steam_entropy() * 1000  # удельная энтропия
        t_s = self.satu_temp_by_satur_pressure() - 273  # температура в области наcыщения
        # параметры для кипящей воды
        h1 = self.spec_enthalpy_of_subcooled_water() * 1000
        s1 = self.spec_entropy_of_subcooled_water() * 1000  # (энтропия кипящей воды)
        v1 = self.volume_of_subcooled_liquid()
        # параметры сухого насыщенного пара
        h2 = self.superheated_steam_enthalpy() * 1000
        s2 = self.superheated_steam_entropy() * 1000
        v2 = self.superheated_steam_volume()
        # параметры идеального обратимого расширения в турбине:
        x1 = (s_tur - s1) / (s2 - s1)
        h_s = h1 + x1 * (h2 - h1)
        # параметры расширения с учетом внутреннего относительного КПД турбины
        h_steam = h_tur - self.kpd_t * (h_tur - h_s)
        x_r = (h_steam - h1) / (h2 - h1)
        ro_steam = 1 / (v1 + x_r * (v2 - v1))
        g_vod = self.water_first(t=self.t_h)
        # оценка тепловых потерь конденсатора через корпус конденсатора в окружающую среду
        t_d = self.t_s - 1  # температура поверхности корпуса
        q_l = self.e_d * 5.67 * (((t_d + 273) / 100) ** 4 - ((self.t_air + 273) / 100) ** 4)
        alpha_d = (0.5 * self.lamb_air / self.d) * (
                (9.8 * (t_d - self.t_air) * self.d ** 3) / ((self.t_air + 273) * self.v_air ** 2) * self.pr_air) ** 0.25

        q_k = alpha_d * (t_d - self.t_air)  # лучистая составляющая теплового потока
        q_d = f_d * (q_l + q_k)  # тепловые потери конденсатора в окружающую среду
        w_steam = self.g_steam / (ro_steam * S_pipe)

        # Блок «Расчет начальных значений для итерационных циклов определения температуры стенки трубок,
        # температуры охлаждающей воды на выходе из конденсатора и массы сконденсированного пара

        c_p_cw = 0.0106 * self.t_h ** 2 - 0.8678 * self.t_h + 4197.1
        t_k_cw = self.t_h + self.g_steam * (h2 - h1) * 0.98 / (c_p_cw * g_vod)  # температура охл воды на выходе из конденсатора
        # температуры стенок труб пучков по средней температуре охлаждающей воды
        t_cw = (self.t_h + t_k_cw) / 2
        t_st1 = (t_s + self.t_h) / 2 - 0.5
        t_st2 = (t_s + self.t_h) / 2 + 0.5
        g_con = x_r * self.g_steam  # приближение для сконденсированного в теплообменники пара
        gc_count = 0.01 * g_con

        # Блок «Расчет теплопередачи с заданными параметрами и оценка невязки по определению температуры стенки ΔtСТ2»

        while True:  # остановка цикла будет вручную в конце при помощи break.
            t_cw = (self.t_h + t_k_cw) / 2
            g_vod = self.water_first(t=t_cw)
            # число (критерий) Прандтля,
            # а по температуре   только число (критерий) Прандтля
            lambd = -8 * 10 ** (-6) * t_cw ** 2 + 0.0019 * t_cw + 0.5634  # коэффициент теплопроводности,
            mu = (-9 * 10 ** (-7) * t_cw ** 3 + 3 * 10 ** (
                -4) * t_cw ** 2 - 0.0333 * t_cw + 1.5816) / 1000  # коэффициент динамической вязкости
            ro_hv = -0.0028 * t_cw ** 2 - 0.1521 * t_cw + 1002.3  # плотность
            pr_cw = -3 * 10 ** (-12) * t_cw ** 6 + 2 * 10 ** (-9) * t_cw ** 5 - 5 * 10 ** (-7) * t_cw ** 4 + 6 * 10 ** (
                -5) * t_cw ** 3 - 0.0019 * t_cw ** 2 - 0.1088 * t_cw + 9.3319
            pr_st1 = -3 * 10 ** (-12) * t_st1 ** 6 + 2 * 10 ** (-9) * t_st1 ** 5 - 5 * 10 ** (-7) * t_st1 ** 4 + 6 * 10 \
                     ** (-5) * t_st1 ** 3 - 0.0019 * t_st1 ** 2 - 0.1088 * t_st1 + 9.3319

            w_cw = g_vod / (ro_hv * s_cw)  # средняя скорость движения охлаждающей воды по трубам
            from math import log
            dt = ((t_s - self.t_h) - (t_s - t_k_cw)) / log((t_s - self.t_h) / (t_s - t_k_cw))  # среднелогарифмический температурный напор

            re = w_cw * self.d1 * ro_hv / mu
            if re > 10000 and (self.lz / self.d1) > 50:
                nu = 0.021 * re ** 0.8 * pr_cw ** 0.43 * (pr_cw / pr_st1) ** 0.25
                alpha_cw = nu * lambd / self.d1
            else:
                print("Напишите функцию для расчета ламинарного режима")
                break
            # определение параметров теплообмена при конденсации пара на поверхностях труб
            lambd_co = -8 * 10 ** (-6) * t_s ** 2 + 0.0019 * t_s + 0.5634  # коэффициент теплопроводности,
            mu_co = (-9 * 10 ** (-7) * t_s ** 3 + 3 * 10 ** (
                -4) * t_s ** 2 - 0.0333 * t_s + 1.5816) / 1000  # коэффициент динамической вязкости
            ro_co = -0.0028 * t_s ** 2 - 0.1521 * t_s + 1002.3  # плотность
            pr_co = -3 * 10 ** (-12) * t_s ** 6 + 2 * 10 ** (-9) * t_s ** 5 - 5 * 10 ** (-7) * t_s ** 4 + 6 * 10 ** (
                -5) * t_s ** 3 - 0.0019 * t_s ** 2 - 0.1088 * t_s + 9.3319
            alpha_n = 0.725 * (lambd_co ** 3 * 9.8 * (ro_co - ro_steam) * (h_steam - h1) / (
                        mu_co / ro_co * (t_s - t_st2) * self.d2)) ** 0.25
            if (ro_steam * w_steam ** 2) >= 1:
                a = 25.7 * (ro_steam * w_steam ** 2 / (9.8 * ro_co * self.d2)) ** 0.25 * (alpha_n * self.d2 / lambd_co)\
                    ** (-0.5)
            else:
                a = 1
            n_rows_h = self.ny
            b = 0.84 * (g_con / self.g_steam) / ((1 - (1 - g_con / self.g_steam) ** 0.84) * n_rows_h ** 0.07)

            alpha_con = alpha_cw * a * b  # Средний по всему трубному пучку коэффициент теплоотдачи при конденсации
            ql = 3.14 * dt / (1 / (alpha_cw * self.d1) + (1 / (2 * self.lambd_d)) * log(self.d2 / self.d1) +
                              1 / (alpha_con * self.d2))
            t_st2_new = t_s - ql / (3.14 * alpha_con * self.d2)
            #t_st1_new = t_st2_new - ql / (2 * 3.14 * lambd_d) * math.log(d2 / d1)

            dt_st2 = abs(t_st2_new - t_st2)

            # Анализ сходимости итерации

            if dt_st2 > 0.1:
                t_st2 = (t_st2 + t_st2_new) / 2
                continue  # возврат в начало цикла

            # Блок «Определение невязки по температуре охлаждающей воды на выходе из конденсатора

            c_p_cw = 0.0106 * t_cw ** 2 - 0.8678 * t_cw + 4197.1
            t_k_cw_new = self.t_h + (ql * self.lz * 2 * self.ns) / (c_p_cw * g_vod)
            dt_cw = abs(t_k_cw_new - t_k_cw)
            if dt_cw > 1:
                t_k_cw = (t_k_cw + t_k_cw_new) / 2
                continue

                # Блок «Определение невязки по массе сконденсированного пара ΔGКОН» ИЗМЕНЕНИЯ
            Gc_new = (ql * self.lz * 2 * self.ns) / (h_steam - h1)
            if Gc_new > x_r * self.g_steam:
                Gc_new = x_r * self.g_steam

            dGc = abs(Gc_new - g_con)
            if dGc > gc_count:
                g_con = (g_con + Gc_new) / 2
                continue
            else:
                break
        return g_vod








